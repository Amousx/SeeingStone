package main

import (
	"crypto-arbitrage-monitor/config"
	"crypto-arbitrage-monitor/internal/exchange/aster"
	"crypto-arbitrage-monitor/internal/exchange/binance"
	"crypto-arbitrage-monitor/internal/exchange/lighter"
	"crypto-arbitrage-monitor/internal/pricestore"
	"crypto-arbitrage-monitor/pkg/common"
	"log"
	"os"
	"os/signal"
	"strconv"
	"sync"
	"syscall"
	"time"
)

func main() {
	// 加载配置
	cfg := config.LoadConfig()

	// 创建日志文件
	logFile, err := os.OpenFile("arbitrage.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err == nil {
		log.SetOutput(logFile)
		defer logFile.Close()
	}

	log.Println("=== Starting Crypto Price Collector ===")

	// 创建价格存储器（双索引结构）
	store := pricestore.NewPriceStore()

	// 启动Aster WebSocket
	asterWS := startAsterWebSocket(store)
	defer asterWS.Close()

	// 启动Aster REST初始化和定期更新
	asterSpotClient := aster.NewSpotClient(cfg.AsterSpotBaseURL, cfg.AsterAPIKey, cfg.AsterSecretKey)
	asterFuturesClient := aster.NewFuturesClient(cfg.AsterFutureBaseURL, cfg.AsterAPIKey, cfg.AsterSecretKey)

	// 启动Lighter WebSocket和REST
	lighterMarkets := lighter.GetCommonMarkets()
	lighterAPIBaseURL := lighter.LighterAPIBaseURL
	marketIDs := lighter.GetMarketIDs(lighterMarkets)
	lighterWS := startLighterWebSocket(store, lighterMarkets, lighterAPIBaseURL)
	if lighterWS != nil {
		defer lighterWS.Close()
	}

	// 配置Binance代理
	if cfg.HTTPSProxy != "" {
		binance.SetProxyURL(cfg.HTTPSProxy)
	} else if cfg.HTTPProxy != "" {
		binance.SetProxyURL(cfg.HTTPProxy)
	}

	// 启动Binance WebSocket
	binanceSpotWS := startBinanceSpotWebSocket(store)
	if binanceSpotWS != nil {
		defer binanceSpotWS.Close()
	}

	binanceFuturesWS := startBinanceFuturesWebSocket(store)
	if binanceFuturesWS != nil {
		defer binanceFuturesWS.Close()
	}

	// 启动后台任务
	var wg sync.WaitGroup
	stopChan := make(chan struct{})

	// 任务1: Aster REST数据获取
	wg.Add(1)
	go func() {
		defer wg.Done()
		runAsterRESTUpdater(asterSpotClient, asterFuturesClient, store, stopChan)
	}()

	// 任务2: Lighter REST数据获取
	wg.Add(1)
	go func() {
		defer wg.Done()
		runLighterRESTUpdater(lighterAPIBaseURL, marketIDs, store, stopChan)
	}()

	// 任务3: Binance REST数据获取
	wg.Add(1)
	go func() {
		defer wg.Done()
		runBinanceRESTUpdater(store, stopChan)
	}()

	// 任务4: 统计信息打印
	wg.Add(1)
	go func() {
		defer wg.Done()
		runStatsReporter(store, stopChan)
	}()

	// 任务5: 定期清理过期数据
	wg.Add(1)
	go func() {
		defer wg.Done()
		runDataCleaner(store, stopChan)
	}()

	// 等待退出信号
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	log.Println("Price collector is running. Press Ctrl+C to stop.")

	<-sigChan
	log.Println("Shutting down gracefully...")

	// 通知所有goroutine停止
	close(stopChan)

	// 等待所有goroutine完成
	wg.Wait()

	log.Println("Shutdown complete.")
}

// startAsterWebSocket 启动Aster WebSocket连接
func startAsterWebSocket(store *pricestore.PriceStore) *aster.WSClient {
	log.Println("[Aster] Connecting to WebSocket...")

	asterWS := aster.NewWSClient("wss://fstream.asterdex.com/ws", common.MarketTypeFuture)

	asterWS.SetMiniTickerHandler(func(tickers []*aster.WSMiniTickerData) {
		for _, ticker := range tickers {
			price := aster.ConvertWSMiniTickerToPrice(ticker, common.ExchangeAster, common.MarketTypeFuture)
			store.UpdatePrice(price)
		}
	})

	if err := asterWS.Connect(); err != nil {
		log.Printf("[Aster] Failed to connect WebSocket: %v", err)
		return nil
	}

	if err := asterWS.Subscribe([]string{"!miniTicker@arr"}); err != nil {
		log.Printf("[Aster] Failed to subscribe: %v", err)
		return nil
	}

	log.Println("[Aster] WebSocket connected and subscribed")
	return asterWS
}

// startLighterWebSocket 启动Lighter WebSocket连接
func startLighterWebSocket(store *pricestore.PriceStore, markets []*lighter.Market, apiBaseURL string) *lighter.WSClient {
	log.Println("[Lighter] Connecting to WebSocket...")

	lighterWS := lighter.NewWSClient("wss://api.lighter.xyz/v1/ws", markets, apiBaseURL, 60)

	lighterWS.SetMessageHandler(func(price *common.Price) {
		store.UpdatePrice(price)
	})

	if err := lighterWS.Connect(); err != nil {
		log.Printf("[Lighter] Failed to connect WebSocket: %v", err)
		return nil
	}

	if err := lighterWS.SubscribeAll(); err != nil {
		log.Printf("[Lighter] Failed to subscribe: %v", err)
		return nil
	}

	log.Println("[Lighter] WebSocket connected and subscribed")
	return lighterWS
}

// startBinanceSpotWebSocket 启动Binance现货WebSocket
func startBinanceSpotWebSocket(store *pricestore.PriceStore) *binance.WSClient {
	log.Println("[Binance Spot] Connecting to WebSocket...")

	binanceSpotWS := binance.NewWSClient("wss://stream.binance.com:443/ws/!miniTicker@arr", common.MarketTypeSpot)

	binanceSpotWS.SetMiniTickerHandler(func(tickers []*binance.WSMiniTickerData) {
		for _, ticker := range tickers {
			price := binance.ConvertWSMiniTickerToPrice(ticker, common.ExchangeBinance, common.MarketTypeSpot)
			store.UpdatePrice(price)
		}
	})

	if err := binanceSpotWS.Connect(); err != nil {
		log.Printf("[Binance Spot] Failed to connect WebSocket: %v", err)
		return nil
	}

	log.Println("[Binance Spot] WebSocket connected")
	return binanceSpotWS
}

// startBinanceFuturesWebSocket 启动Binance合约WebSocket
func startBinanceFuturesWebSocket(store *pricestore.PriceStore) *binance.WSClient {
	log.Println("[Binance Futures] Connecting to WebSocket...")

	binanceFuturesWS := binance.NewWSClient("wss://fstream.binance.com/ws/!miniTicker@arr", common.MarketTypeFuture)

	binanceFuturesWS.SetMiniTickerHandler(func(tickers []*binance.WSMiniTickerData) {
		for _, ticker := range tickers {
			price := binance.ConvertWSMiniTickerToPrice(ticker, common.ExchangeBinance, common.MarketTypeFuture)
			store.UpdatePrice(price)
		}
	})

	if err := binanceFuturesWS.Connect(); err != nil {
		log.Printf("[Binance Futures] Failed to connect WebSocket: %v", err)
		return nil
	}

	log.Println("[Binance Futures] WebSocket connected")
	return binanceFuturesWS
}

// runAsterRESTUpdater 运行Aster REST API更新任务
func runAsterRESTUpdater(spotClient *aster.SpotClient, futuresClient *aster.FuturesClient, store *pricestore.PriceStore, stopChan <-chan struct{}) {
	// 立即执行一次初始化
	fetchAsterPrices(spotClient, futuresClient, store)

	// 冷启动阶段：前60秒每5秒更新一次
	coldStartTicker := time.NewTicker(5 * time.Second)
	startTime := time.Now()

	for {
		select {
		case <-stopChan:
			coldStartTicker.Stop()
			return
		case <-coldStartTicker.C:
			if time.Since(startTime) < 60*time.Second {
				fetchAsterPrices(spotClient, futuresClient, store)
			} else {
				coldStartTicker.Stop()
				goto normalMode
			}
		}
	}

normalMode:
	// 正常阶段：每30秒更新一次
	normalTicker := time.NewTicker(30 * time.Second)
	defer normalTicker.Stop()

	for {
		select {
		case <-stopChan:
			return
		case <-normalTicker.C:
			fetchAsterPrices(spotClient, futuresClient, store)
		}
	}
}

// runLighterRESTUpdater 运行Lighter REST API更新任务
func runLighterRESTUpdater(apiBaseURL string, marketIDs []int, store *pricestore.PriceStore, stopChan <-chan struct{}) {
	// 立即执行一次初始化
	fetchLighterPrices(apiBaseURL, marketIDs, store)

	// 冷启动阶段：前60秒每5s更新一次
	coldStartTicker := time.NewTicker(5 * time.Second)
	startTime := time.Now()

	for {
		select {
		case <-stopChan:
			coldStartTicker.Stop()
			return
		case <-coldStartTicker.C:
			if time.Since(startTime) < 60*time.Second {
				fetchLighterPrices(apiBaseURL, marketIDs, store)
			} else {
				coldStartTicker.Stop()
				goto normalMode
			}
		}
	}

normalMode:
	// 正常阶段：每30秒更新一次
	normalTicker := time.NewTicker(30 * time.Second)
	defer normalTicker.Stop()

	for {
		select {
		case <-stopChan:
			return
		case <-normalTicker.C:
			fetchLighterPrices(apiBaseURL, marketIDs, store)
		}
	}
}

// runBinanceRESTUpdater 运行Binance REST API更新任务
func runBinanceRESTUpdater(store *pricestore.PriceStore, stopChan <-chan struct{}) {
	// 立即执行一次初始化
	fetchBinancePrices(store)

	// 冷启动阶段：前60秒每10秒更新一次
	coldStartTicker := time.NewTicker(10 * time.Second)
	startTime := time.Now()

	for {
		select {
		case <-stopChan:
			coldStartTicker.Stop()
			return
		case <-coldStartTicker.C:
			if time.Since(startTime) < 60*time.Second {
				fetchBinancePrices(store)
			} else {
				coldStartTicker.Stop()
				goto normalMode
			}
		}
	}

normalMode:
	// 正常阶段：每60秒更新一次
	normalTicker := time.NewTicker(60 * time.Second)
	defer normalTicker.Stop()

	for {
		select {
		case <-stopChan:
			return
		case <-normalTicker.C:
			fetchBinancePrices(store)
		}
	}
}

// runStatsReporter 定期打印统计信息
func runStatsReporter(store *pricestore.PriceStore, stopChan <-chan struct{}) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-stopChan:
			return
		case <-ticker.C:
			stats := store.GetStats()
			activePrices := len(store.GetActivePrices(60 * time.Second))

			log.Printf("[Stats] Total: %d prices, Active: %d, Symbols: %d, Exchanges: %d",
				stats.TotalPrices, activePrices, stats.TotalSymbols, stats.TotalExchanges)

			for exchange, count := range stats.ByExchange {
				log.Printf("  - %s: %d prices", exchange, count)
			}
		}
	}
}

// runDataCleaner 定期清理过期数据
func runDataCleaner(store *pricestore.PriceStore, stopChan <-chan struct{}) {
	ticker := time.NewTicker(5 * time.Minute)
	defer ticker.Stop()

	for {
		select {
		case <-stopChan:
			return
		case <-ticker.C:
			removed := store.CleanStaleData(10 * time.Minute)
			if removed > 0 {
				log.Printf("[Cleaner] Removed %d stale price entries", removed)
			}
		}
	}
}

// fetchAsterPrices 获取Aster价格数据
func fetchAsterPrices(spotClient *aster.SpotClient, futuresClient *aster.FuturesClient, store *pricestore.PriceStore) {
	var wg sync.WaitGroup

	// 获取现货价格
	wg.Add(1)
	go func() {
		defer wg.Done()
		tickers, err := spotClient.GetAllBookTickers()
		if err != nil {
			log.Printf("[Aster Spot] Failed to fetch prices: %v", err)
			return
		}

		tickers24h, err := spotClient.GetAll24hrTickers()
		if err != nil {
			log.Printf("[Aster Spot] Failed to fetch 24h data: %v", err)
			return
		}

		volumeMap := make(map[string]float64)
		for _, t := range tickers24h {
			volumeMap[t.Symbol] = parseFloat(t.QuoteVolume)
		}

		for _, ticker := range tickers {
			volume := volumeMap[ticker.Symbol]
			price := spotClient.ConvertToCommonPrice(&ticker, volume)
			store.UpdatePrice(price)
		}

		log.Printf("[Aster Spot] Fetched %d prices", len(tickers))
	}()

	// 获取合约价格
	wg.Add(1)
	go func() {
		defer wg.Done()
		tickers, err := futuresClient.GetAllBookTickers()
		if err != nil {
			log.Printf("[Aster Futures] Failed to fetch prices: %v", err)
			return
		}

		tickers24h, err := futuresClient.GetAll24hrTickers()
		if err != nil {
			log.Printf("[Aster Futures] Failed to fetch 24h data: %v", err)
			return
		}

		volumeMap := make(map[string]float64)
		for _, t := range tickers24h {
			volumeMap[t.Symbol] = parseFloat(t.QuoteVolume)
		}

		for _, ticker := range tickers {
			volume := volumeMap[ticker.Symbol]
			price := futuresClient.ConvertToCommonPrice(&ticker, volume)
			store.UpdatePrice(price)
		}

		log.Printf("[Aster Futures] Fetched %d prices", len(tickers))
	}()

	wg.Wait()
}

// fetchLighterPrices 获取Lighter价格数据
func fetchLighterPrices(apiBaseURL string, marketIDs []int, store *pricestore.PriceStore) {
	prices, err := lighter.FetchMarketData(apiBaseURL, marketIDs)
	if err != nil {
		log.Printf("[Lighter] Failed to fetch prices: %v", err)
		return
	}

	for _, price := range prices {
		store.UpdatePrice(price)
	}

	log.Printf("[Lighter] Fetched %d prices", len(prices))
}

// fetchBinancePrices 获取Binance价格数据
func fetchBinancePrices(store *pricestore.PriceStore) {
	var wg sync.WaitGroup

	// 获取现货价格
	wg.Add(1)
	go func() {
		defer wg.Done()
		prices, err := binance.FetchSpotPrices()
		if err != nil {
			log.Printf("[Binance Spot] Failed to fetch prices: %v", err)
			return
		}

		for _, price := range prices {
			store.UpdatePrice(price)
		}

		log.Printf("[Binance Spot] Fetched %d prices", len(prices))
	}()

	// 获取合约价格
	wg.Add(1)
	go func() {
		defer wg.Done()
		prices, err := binance.FetchFuturesPrices()
		if err != nil {
			log.Printf("[Binance Futures] Failed to fetch prices: %v", err)
			return
		}

		for _, price := range prices {
			store.UpdatePrice(price)
		}

		log.Printf("[Binance Futures] Fetched %d prices", len(prices))
	}()

	wg.Wait()
}

// parseFloat 解析字符串为float64
func parseFloat(s string) float64 {
	f, err := strconv.ParseFloat(s, 64)
	if err != nil {
		return 0
	}
	return f
}
